---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  warning = F
)
```

# Brief of scRCD

<!-- badges: start -->

<!-- badges: end -->

The goal of scRCD (Rare Cell Detection of Single-Cell RNA-seq data) is to calculate the rareness scores for each cell from scRNA-seq data and selected the desired number of rare cells by the ranks of rareness scores. scRCD uses a simple and fast spectral clustering-based model to select the calculate the extent that how "far" each cell is from the majority cells. The model will be briefly recapped in the following two subsections.

## Spectral clustering-based optimization

Assume we have a cell-cell affinity matrix $W$ such that the Laplacian matrix $L$ and degress matrix $\Lambda$ of $W$ can be defined as:

$$
  \Lambda=diag(\boldsymbol{1}^T\cdot W)\\
  L = \Lambda-W
$$

Similar to spectral clustering, if $N$ rare cells are desired, then the target cells can be obtained by cutting the whole data set into $N+1$ clusters, where $N$ clusters only contain 1 cell and the rest one cluster contains all the rest cells. This objective can be achieved by minimizing the sum of edges between clusters:

$$
  \underset{C^*\subset C,\boldsymbol{card}(C^*)=N}{\arg\min}\sum\limits_{c^*\in C^*}E(v_{c^*},V/\{v_{c^*}\})
$$

where $V$ is the collection of nodes representing each cell and $v_{c}$ is the node for cell index$c$, and $E(v_{c},V/\{v_{c}\})$ is the sum of edges between $v_c$ and the remaining cells. This problem is equivalent to finding the $N$ smallest elements of the diagonal of the Laplacian matrix $L$:

$$
\underset{C^*\subset C,\boldsymbol{card}(C^*)=N}{\arg\min}\sum\limits_{c^*\in C^*} L_{c^*,c^*}
$$

The higher $L_{c,c}$ represents the better connection of cell $c$ to the remaining cells, thus we can obtain the rareness score $S_c$ for cell $c$ as the opposite of standardized $L_{c,c}$ :

$$
S_c = -\frac{L_{c,c}-\min\limits_{c\in C} L_{c,c}}{\max\limits_{c\in C} L_{c,c}-\min\limits_{c\in C} L_{c,c}}
$$

## Construction of affinity matrix $W$

Here we construct a sparse cell-cell affinity matrix by the following steps.

First, we randomly uniformly sample anchor cells from the whole data set, denote $a\in A$.

Then a distance matrix $H$ is obtained such that each element represents the Euclidean distance between the cell and anchor cells. Let $\boldsymbol{F}_c$ refers to the feature vector for cell $c$, then the $H$ formulates as:

$$
  H_{c,a} = d(\boldsymbol{F}_c,\boldsymbol{F}_a)
$$

Thereafter we calculate the minimal distance of cell $c$ between anchor cells as:

$$
  D_{min,c} = \min_{a\in A,a\neq c}d(\boldsymbol{F}_c,\boldsymbol{F}_a)
$$

Given the $\alpha$, we can calculate the $\alpha$-percentage quantile for $\{D_{min,c}|c\in C\}$ (we use $\alpha = 0.975$ by default).

$$
  Q = \mbox{the } \alpha \mbox{ percentage quantile of }\{D_{min,c}|c\in C\}
$$

We use $Q$ as a threshold such that the edges with distance from anchor cells less than $Q$ retain while edges with larger distances vanish to zeros, in order to preserve the local data structure. For the retained edges between cell $c$ and the anchor cells, we calculate the edges in a $k_c$-NN manner ($k_c$ is the number of non-zero distances from cell $c$ in $H$ )$$
  B_{c,a} = \left\{
             \begin{array}{lr}
             (D_{min,c}-H_{c,a})/(k_cD_{min,c}-\sum\limits_{i,H_{c,i}<Q}H_{c,i}) &,  H_{c,a}<Q\\
             0 &,  H_{c,a}\geq Q
             \end{array}
\right. \mbox{   for  } \min\limits_{c}{H_{c,a}}\leq Q
$$

For the cell whose nearest anchor cell is still beyond $D_{min,c}$, we set the bipartite element between the cell and the nearest anchor cell as 1, in order to keep the bipartite and affinity matrix complete:$$
  B_{c,a} = \left\{
             \begin{array}{lr}
             1 &,  H_{c,a} = \min\limits_{a}{H_{c,a}}\\
             0 &,  H_{c,a}> \min\limits_{a}{H_{c,a}}
             \end{array}
\right.\quad\mbox{for  } \min\limits_{a}{H_{c,a}}> Q
$$

Consequently we obtained a sparse bipartite, thus finally a sparse affinity matrix is generated by:$$
  W = BB^T
$$

# Installation

You can install the development version of scRCD like so:

``` r
devtools::install_github("AristoQian/scRCD")
```

# Example

## Computing rareness scores

First we load scRCD and the two attached example data sets :

```{r example}
library(scRCD)
# gene-barcode matrix
data(marrow)
# cell subtype data
data(cell.type.marrow)
dim(marrow)
dim(cell.type.marrow)
```

Then PCA is performed for dimension reduction:

```{r running}
pc.marrow<-prcomp(t(marrow))
head(pc.marrow$x[,1:25])
```

Top 25 PCs are selected as cell features

scRCD main function is called to compute rareness scores by repeating 10 times:

```{r scRCD, echo = FALSE}
scores<-scRCD(pc = pc.marrow$x[,1:25],n.cores = 1)
```

## Visualization and comparison to current methods

First, perform t-SNE given the top PCs:

```{r tsne}
library(Rtsne)
tsne<- Rtsne(pc.marrow$x[,1:25],pca=F,dims=2,perplexity=30,theta=0.5)
head(tsne$Y)
```

Then we can called the visualization function to compare the rare cells of different fractions (0.025,0.05,0.075,0.5)

```{r visualization}
library(cowplot)
vis<-scRCD.visualize(tsne = tsne, scores = scores, cell.type = cell.type.marrow, frac.list = c(0.025,0.05,0.075,0.1))
#tSNE for the rare cells
plt.rare<-plot_grid(vis$plt.frac.list$`0.025`,vis$plt.frac.list$`0.05`,
               vis$plt.frac.list$`0.075`,vis$plt.frac.list$`0.1`,
               nrow = 2, ncol = 2)
plt.rare
```

```{r}
plt.all<-vis$plt.all.cell
plt.all
```

We can also compare our result to, FiRE, another novel method for rare cell detection:

```{r FiRE}
library(FiRE)
rnames <- rownames(t(marrow))
cnames <- colnames(t(marrow))

L <- 100 # Number of estimators
M <- 50 # Dims to be sampled

# Model creation without optional parameter
model <- new(FiRE::FiRE, L, M)

## There are 3 more optional parameters they can be passed as
## model <- new(FiRE::FiRE, L, M, H, seed, verbose)
## Hashing all samples
model$fit(as.matrix(t(marrow)))

## Computing score of each sample
scores.fire <- model$score(as.matrix(t(marrow)))

vis.fire<-scRCD.visualize(tsne = tsne, scores = scores.fire, cell.type = cell.type.marrow, frac.list = c(0.025,0.05,0.075,0.1))
plt.rare.fire<-plot_grid(vis.fire$plt.frac.list$`0.025`,
                         vis.fire$plt.frac.list$`0.05`,
                         vis.fire$plt.frac.list$`0.075`,
                         vis.fire$plt.frac.list$`0.1`,
                         nrow = 2, ncol = 2)
plt.rare.fire
```

```{r}
plt.all.fire<-vis.fire$plt.all.cell
plt.all.fire
```
